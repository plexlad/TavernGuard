"use strict";
var _Subcommand_instances, _Subcommand_handleMessageRun, _Subcommand_handleChatInputInteractionRun, _Subcommand_findSubcommand;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Subcommand = void 0;
const tslib_1 = require("tslib");
const framework_1 = require("@sapphire/framework");
const utilities_1 = require("@sapphire/utilities");
const Events_1 = require("./types/Events");
class Subcommand extends framework_1.Command {
    constructor(context, options) {
        super(context, options);
        _Subcommand_instances.add(this);
        Object.defineProperty(this, "parsedSubcommandMappings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "caseInsensitiveSubcommands", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        this.parsedSubcommandMappings = options.subcommands ?? [];
        const clientOptions = this.container.client.options;
        if (clientOptions.caseInsensitiveCommands) {
            this.caseInsensitiveSubcommands = true;
            // Because slash commands must be lowercase anyway, we can transform all to lowercase.
            for (const cmd of this.parsedSubcommandMappings) {
                cmd.name = cmd.name.toLowerCase();
                if (cmd.type === 'group') {
                    for (const groupCommand of cmd.entries) {
                        groupCommand.name = groupCommand.name.toLowerCase();
                    }
                }
            }
        }
        if (options.generateDashLessAliases) {
            for (const mapping of this.parsedSubcommandMappings) {
                if (!Reflect.has(mapping, 'messageRun')) {
                    continue;
                }
                const dashLessMappings = [];
                if (mapping.type === 'group') {
                    // Keep track of whether we have changed entries or not, so we don't need to do expensive object comparison later.
                    let hasChangedEntries = null;
                    // Deeply clone the entire mapping to avoid mutating the original.
                    const clonedMapping = (0, utilities_1.deepClone)(mapping);
                    // Loop through the group's subcommands and add a dash-less alias for each, if applicable.
                    for (const groupCommand of mapping.entries) {
                        if (groupCommand.name.includes('-')) {
                            // If we are inside this if statement then we flip `hasChangedEntries` to true to be able to read it later.
                            hasChangedEntries ?? (hasChangedEntries = true);
                            clonedMapping.entries.push({
                                ...groupCommand,
                                name: groupCommand.name.replaceAll('-', '')
                            });
                        }
                    }
                    /**
                     * If any of the entries in the group had a dash then `hasChangedEntries` was flipped to true
                     * and so we want to register a mapping with the base name and all dash-less entries
                     * in the group.
                     */
                    if (hasChangedEntries) {
                        dashLessMappings.push({
                            ...mapping,
                            entries: clonedMapping.entries
                        });
                    }
                    /**
                     * If the group name itself has a dash then register a dash-less copy of it.
                     * If the entries in the group didn't have any dashes then `clonedMapping.entries` is still
                     * the same original array, so it can be safely overwritten.
                     *
                     * If the entries in the group did have any dashes then `clonedMapping.entries` has
                     * all entries both with and without dashes.
                     */
                    if (clonedMapping.name.includes('-')) {
                        clonedMapping.name = clonedMapping.name.replaceAll('-', '');
                        dashLessMappings.push(clonedMapping);
                    }
                }
                else if (mapping.name.includes('-')) {
                    dashLessMappings.push({
                        ...mapping,
                        name: mapping.name.replaceAll('-', '')
                    });
                }
                // For every dash-less mapping, push a new subcommand
                for (const dashLessMapping of dashLessMappings) {
                    this.parsedSubcommandMappings.push(dashLessMapping);
                }
            }
        }
    }
    onLoad() {
        super.onLoad();
        const externalMapping = Reflect.get(this, 'subcommandMappings');
        if (externalMapping) {
            const subcommands = Array.isArray(externalMapping) ? externalMapping : [];
            this.parsedSubcommandMappings = subcommands;
            this.options.subcommands = subcommands;
        }
    }
    async messageRun(message, args, context) {
        args.save();
        const subcommandOrGroup = args.nextMaybe();
        const subcommandName = args.nextMaybe();
        let defaultCommand = null;
        let actualSubcommandToRun = null;
        let matchedWithGroupedSubcommand = false;
        for (const mapping of this.parsedSubcommandMappings) {
            mapping.type ?? (mapping.type = 'method');
            if (mapping.type === 'method') {
                if (mapping.default) {
                    matchedWithGroupedSubcommand = false;
                    defaultCommand = mapping;
                }
                if (subcommandOrGroup.isSomeAnd((value) => mapping.name === (this.caseInsensitiveSubcommands ? value.toLowerCase() : value))) {
                    actualSubcommandToRun = mapping;
                    matchedWithGroupedSubcommand = false;
                    // Exit early
                    break;
                }
            }
            // We expect a group mapping
            if (mapping.type === 'group' && subcommandOrGroup.isSome() && subcommandName.isSome()) {
                const unwrappedSubcommandGroupName = subcommandOrGroup.unwrap();
                const unwrappedSubcommandName = subcommandName.unwrap();
                // We know a group was passed in here
                if (mapping.name === unwrappedSubcommandGroupName) {
                    // Find the actual subcommand to run
                    const findResult = tslib_1.__classPrivateFieldGet(this, _Subcommand_instances, "m", _Subcommand_findSubcommand).call(this, mapping.entries, this.caseInsensitiveSubcommands ? unwrappedSubcommandName.toLowerCase() : unwrappedSubcommandName);
                    if (findResult.defaultMatch) {
                        defaultCommand = findResult.mapping;
                        matchedWithGroupedSubcommand = true;
                    }
                    else {
                        actualSubcommandToRun = findResult.mapping;
                        matchedWithGroupedSubcommand = true;
                        // Exit early
                        break;
                    }
                }
            }
        }
        // Preemptively restore the args state, to provide a correct args result for users
        args.restore();
        if (actualSubcommandToRun) {
            // Skip over the subcommandOrGroup
            args.next();
            // If we matched with a subcommand in a group we need to skip 1 more arg
            if (matchedWithGroupedSubcommand) {
                args.next();
            }
            return tslib_1.__classPrivateFieldGet(this, _Subcommand_instances, "m", _Subcommand_handleMessageRun).call(this, message, args, context, actualSubcommandToRun);
        }
        // No subcommand matched, let's try to run default, if any:
        if (defaultCommand) {
            if (subcommandOrGroup.isSome()) {
                args.next();
            }
            // If we matched with a subcommand in a group we need to skip 1 more arg
            if (matchedWithGroupedSubcommand) {
                args.next();
            }
            return tslib_1.__classPrivateFieldGet(this, _Subcommand_instances, "m", _Subcommand_handleMessageRun).call(this, message, args, context, defaultCommand);
        }
        // No match and no subcommand, return an err:
        throw new framework_1.UserError({
            identifier: Events_1.SubcommandPluginIdentifiers.MessageSubcommandNoMatch,
            message: 'No subcommand was matched with the provided arguments.',
            context: {
                ...context,
                possibleSubcommandName: subcommandName.unwrapOr(null),
                possibleSubcommandGroupOrName: subcommandOrGroup.unwrapOr(null)
            }
        });
    }
    async chatInputRun(interaction, context) {
        const subcommandName = interaction.options.getSubcommand(false);
        const subcommandGroupName = interaction.options.getSubcommandGroup(false);
        for (const mapping of this.parsedSubcommandMappings) {
            mapping.type ?? (mapping.type = 'method');
            // If we have a group, we know we also have a subcommand and we should find and run it
            if (subcommandGroupName && subcommandName) {
                if (mapping.type !== 'group')
                    continue;
                if (mapping.name !== subcommandGroupName)
                    continue;
                const foundSubcommand = tslib_1.__classPrivateFieldGet(this, _Subcommand_instances, "m", _Subcommand_findSubcommand).call(this, mapping.entries, subcommandName);
                // Only run if its not the "default" found command mapping, as interactions don't have that
                if (!foundSubcommand.defaultMatch) {
                    return tslib_1.__classPrivateFieldGet(this, _Subcommand_instances, "m", _Subcommand_handleChatInputInteractionRun).call(this, interaction, context, foundSubcommand.mapping);
                }
                // Skip to the next entry
                continue;
            }
            // If we have a direct subcommand, and no group, then run the mapping
            if (mapping.type === 'method' && mapping.name === subcommandName) {
                return tslib_1.__classPrivateFieldGet(this, _Subcommand_instances, "m", _Subcommand_handleChatInputInteractionRun).call(this, interaction, context, mapping);
            }
        }
        // No match and no subcommand, return an err:
        throw new framework_1.UserError({
            identifier: Events_1.SubcommandPluginIdentifiers.ChatInputSubcommandNoMatch,
            message: 'No subcommand was matched with the provided command.',
            context
        });
    }
}
exports.Subcommand = Subcommand;
_Subcommand_instances = new WeakSet(), _Subcommand_handleMessageRun = async function _Subcommand_handleMessageRun(message, args, context, subcommand) {
    const payload = {
        message,
        command: this,
        context,
        matchedSubcommandMapping: subcommand
    };
    const result = await framework_1.Result.fromAsync(async () => {
        if (subcommand.messageRun) {
            const casted = subcommand;
            this.container.client.emit(Events_1.SubcommandPluginEvents.MessageSubcommandRun, message, casted, payload);
            let result;
            if (typeof subcommand.messageRun === 'string') {
                const method = Reflect.get(this, subcommand.messageRun);
                if (!method) {
                    throw new framework_1.UserError({
                        identifier: Events_1.SubcommandPluginIdentifiers.SubcommandNotFound,
                        message: `The method configured at "messageRun" for the subcommand ${subcommand.name} was not implemented in the class.`,
                        context: { ...payload }
                    });
                }
                result = await Reflect.apply(method, this, [message, args, context]);
            }
            else {
                result = await subcommand.messageRun(message, args, context);
            }
            this.container.client.emit(Events_1.SubcommandPluginEvents.MessageSubcommandSuccess, message, casted, { ...payload, result });
        }
        else {
            this.container.client.emit(Events_1.SubcommandPluginEvents.SubcommandMappingIsMissingMessageCommandHandler, message, subcommand, payload);
        }
    });
    result.inspectErr((error) => this.container.client.emit(Events_1.SubcommandPluginEvents.MessageSubcommandError, error, payload));
}, _Subcommand_handleChatInputInteractionRun = async function _Subcommand_handleChatInputInteractionRun(interaction, context, subcommand) {
    const payload = {
        command: this,
        context,
        interaction,
        matchedSubcommandMapping: subcommand
    };
    const result = await framework_1.Result.fromAsync(async () => {
        if (subcommand.chatInputRun) {
            const casted = subcommand;
            this.container.client.emit(Events_1.SubcommandPluginEvents.ChatInputSubcommandRun, interaction, casted, payload);
            let result;
            if (typeof subcommand.chatInputRun === 'string') {
                const method = Reflect.get(this, subcommand.chatInputRun);
                if (!method) {
                    throw new framework_1.UserError({
                        identifier: Events_1.SubcommandPluginIdentifiers.SubcommandNotFound,
                        message: `The method configured at "chatInputRun" for the subcommand ${subcommand.name} was not implemented in the class.`,
                        context: { ...payload }
                    });
                }
                result = await Reflect.apply(method, this, [interaction, context]);
            }
            else {
                result = await subcommand.chatInputRun(interaction, context);
            }
            this.container.client.emit(Events_1.SubcommandPluginEvents.ChatInputSubcommandSuccess, interaction, casted, { ...payload, result });
        }
        else {
            this.container.client.emit(Events_1.SubcommandPluginEvents.SubcommandMappingIsMissingChatInputCommandHandler, interaction, subcommand, payload);
        }
    });
    result.inspectErr((error) => this.container.client.emit(Events_1.SubcommandPluginEvents.ChatInputSubcommandError, error, payload));
}, _Subcommand_findSubcommand = function _Subcommand_findSubcommand(mappings, expectedName) {
    let foundDefault = null;
    for (const mapping of mappings) {
        mapping.type ?? (mapping.type = 'method');
        if (mapping.default) {
            foundDefault = mapping;
        }
        if (mapping.name === expectedName) {
            return { mapping, defaultMatch: false };
        }
    }
    return { mapping: foundDefault, defaultMatch: true };
};
//# sourceMappingURL=Subcommand.js.map